/***************************************************************************
 *            qsf-xml.h
 *
 *  Fri Nov 26 19:29:47 2004
 *  Copyright  2004-2005  Neil Williams  <linux@codehelp.co.uk>
 *
 ****************************************************************************/
/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

 #ifndef QSF_XML_H
 #define QSF_XML_H

/** @addtogroup Backend
    @{ */
/** @addtogroup QSF QOF Serialisation Format

QSF - QOF Serialization Format is an XML serialization format
i.e. it lays out a QOF object in a series of XML tags. The format will  
consist of two component formats:

qof-qsf for the QSF object data and

qsf-map to map sets of QSF objects between QOF applications.

QSF object files will contain user data and are to be exported from QOF applications 
under user control or they can be hand-edited. QSF maps contain application data and 
can be created by application developers from application source code. Tools may be 
created later to generate maps interactively but maps require application support as 
well as an understanding of QOF objects in the import and output applications and are 
intended to remain within the scope of application developers rather than users.

A QSF file written by one QOF application will need an appropriate QSF map before the 
data can be accessed by a different application using QOF. Any QSF objects that are 
not defined in the map will be ignored. QSF files written and accessed by the same 
application can use maps if necessary or can simply import the QSF data as a whole.

Unless specifically mentioned otherwise, all defined strings are case-sensitive.

Full documentation of this format is at:

http://code.neil.williamsleesmill.me.uk/qsf.html

QSF itself is now being built into the QOF library for use with pilot-link to allow
Palm objects to be described in QOF, written to XML as QSF and imported directly into 
GnuCash and other QOF-compliant applications. As a generic format, it does not depend 
on any pre-defined objects - as the current GnuCash XML format depends on AccountGroup. 
Instead, QSF is a simple container for all QOF objects.

QSF grew from the qof_book_merge code base and uses the qof_book_merge code that is now 
part of QOF. Any QofBook generated by QSF still needs to be merged into the existing 
application data using qof_book_merge. See ::BookMerge.

QSF can be used as an export or offline storage format for QOF applications (although 
long term storage may be best performed using separate (non-XML) methods, depending 
on the application).

QSF is designed to cope with partial QofBooks at the QofObject level. There is no 
requirement for specific objects to always be defined, as long as each QOF object 
specified is fully defined, no orphan or missing parameters are allowed.

Work is continuing on supporting QSF in GnuCash and QOF. QSF is a very open format - 
the majority of the work will be in standardising object types and creating maps that 
convert between objects. Applications that read QSF should ignore any objects that do 
not match the available maps and warn the user about missing data. 

Anyone is free to create their own QSF objects, subject to the GNU GPL. It is intended 
that QSF can be used as the flexible, open and free format for QOF data - providing 
all that is lacking from a typical CSV export with all the validation benefits of XML 
and the complex data handling of QOF. The QSF object and map formats remain under the 
GNU GPL licence and QSF is free software.

\todo
	- Adding more map support, some parts of the map are still not coded. equals, 
		variables and the conditional logic may not be up to the task of the
		datebook repetition calculations.
	- Rationalise the API - remove functions that shouldn't be public.

QSF is in three sections:
	- QSF Backend : a QofBackend for file:/ QSF objects and maps.
		qsf-backend.c
	- QSF Object  : Input, export and validation of QSF object files.
		qsf-xml.c
	- QSF Map : Validation, processing and conversion routines.
		qsf-xml-map.c

    @{ */
/** @file qsf-xml.h
    @brief  QSF API - Backend, maps and objects.
    @author Copyright (C) 2004-2005 Neil Williams <linux@codehelp.co.uk>
*/

#include <stdio.h>
#include <stdlib.h>
#include <glib.h>
#include <regex.h>
#include <time.h>
#include <libxml/xmlmemory.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <libxml/xmlschemas.h>
#include "gnc-date.h"
#include "qof_book_merge.h"
#include "qofbook.h"
#include "qofclass.h"
#include "qofobject.h"
#include "qofbackend-p.h"
#include "qofsession.h"

typedef enum  {
	QSF_UNDEF = 0, /**< Initial undefined value. */
	IS_QSF_MAP,   /**< A QSF map */
	IS_QSF_OBJ,   /**< A QSF object without a map - it may or may not need one. */
	HAVE_QSF_MAP, /**< A QSF object with the map it needs. */
	OUR_QSF_OBJ,  /**< A QSF object that can be loaded without a map. */
}qsf_type;
	
/** \internal Holds a description of the QofObject.

Used when converting QOF objects from another application. The incoming,
\b unknown, objects need to be stored prior to conversion. This allows 
many-to-many conversions where an invoice can receive data from an incoming
expense AND datebook and use data from an incoming contacts object to lookup
the customer for the invoice.
*/
typedef struct qsf_object_set
{
	GHashTable *parameters;
	QofIdType object_type;
	int object_count;
}qsf_objects;

#define QSF_QOF_VERSION QOF_OBJECT_VERSION /**< QOF Version check.

Make sure the same version of QOF is in use in both applications.
*/
#define QSF_ROOT_TAG	"qof-qsf" /**< The top level root tag */
#define QSF_DEFAULT_NS	"urn:qof-qsf-container" /**< Default namespace for QSF root tag

The map namespace is not included as maps are not currently written out by QOF.
*/
#define QSF_DATE_LENGTH 31 /**< Max length of QSF_XSD_TIME */
#define QSF_BOOK_TAG	"book" /**< First level child: book tag - the ::QofBook. */
#define QSF_BOOK_GUID	"book-guid" /**< QOF GUID tag for the QofBook described by this QSF object file */
#define QSF_BOOK_COUNT	"count" /**< Sequential counter of each book in this file */
#define QSF_OBJECT_TAG	"object" /**< Second level child: object tag */
#define QSF_OBJECT_TYPE	"type" /**< QSF parameter name for object type specifiers */
#define QSF_OBJECT_COUNT	"count" /**< Sequential counter for each QSF object in this file */
#define QSF_XML_VERSION	"1.0"  /**< The current XML version. */
#define MAP_ROOT_TAG	"qsf-map" /**< Top level root tag for QSF Maps */
#define MAP_DEFINITION_TAG	"definition" /**< Second level container for defined objects 

Attributes: qof_version - Taken from the QOF_OBJECT_VERSION macro in QOF,
At the time of QSF development, QOF_OBJECT_VERSION is defined as 3. All
QSF maps and QSF objects must use the same qof_version which in turn must
match the QOF_OBJECT_VERSION for the QOF library in use by the calling process.

No text content allowed.
*/
#define MAP_DEFINE_TAG	"define" /**< defines each object supported by this QSF map 

Attributes: e_type Copied directly from the QofObject definition.
Content: The full QofObject description for the defined QOF object.
*/
#define MAP_DEFAULT_TAG	"default"  /**< User editable defaults for data not available within the available QSF objects.

Some defaults will relate to how to format descriptive dates, whether discount should be considered,
which account to use for certain QSF data from applications that don't use accounts.

Some defaults are pre-defined and cannot be over-written:
- qsf_time_now
- qsf_time_string

Attributes (All are mandatory): 

\a name The text name for this default. Certain pre-defined defaults exist but user- or map-defined defaults can have any unique text name. Spaces are \b NOT allowed, use undersccores instead. The value of name must not duplicate any existing default, define, object or parameter unless the special type, enum, is used.

\a type QOF_TYPE - must be one of the recognised QOF data types for the
qof_version in use or the special type, enum.

\a value Text representation of the required value. For numeric, use the format
[0-9]?/[0-9]?

\attention Using boolean defaults
A boolean default is not output in the QSF directly, instead the value is
used in the calculations to modify certain values. If the boolean default
is set to true, the if statement containing the boolean name will be evaluated. If the boolean
default is set to false, the corresponding else will be evaluted. Make sure your
calculations contain an appropriate else statement so that the boolean value
can be adjusted without invalidating the map!

\attention Using enumerators
- enum types are the only defaults that are allowed to use the same name value more than once. 
- enum types are used to increase the readability of a QSF map.
- The enum name acts to group the enum values together - in a similar fashion to radio buttons in HTML forms. 
- enum types are used only where the QOF object itself uses an enum type. 

e.g. the tax_included enum type allows maps to use the full name of the enum value GNC_TAXINCLUDED_YES, instead of the cryptic digit value, 1.

*/
#define MAP_OBJECT_TAG	"object" /**< Contains all the calculations to make one object from others.

Note that creating an object for the import application can involve using data from more than one
QSF object, as well as defaults and lookups in the import application itself. Conditionals, simple
arithmetic and date/time formatting options are also available.
*/
#define MAP_CALCULATE_TAG	"calculate" /**< One calculation for every parameter that needs to be set.

QSF follows the same rule as qof_book_merge. Only if a getter and a setter function are defined for
a parameter is it available to QSF. If a ::QofAccessFunc and ::QofSetterFunc are both defined
for any QofObject parameter, that parameter \b MUST be calculated in any map that defines that object.
*/
#define MAP_QOF_VERSION	"qof_version" /**< This is the QOF_OBJECT_VERSION >From QOF.

QSF maps may need to be updated if QOF itself is upgraded. This setting is coded into QOF and 
maps for one version cannot necessarily be used by other versions. At the first release of QSF,
QOF_OBJECT_VERSION = 3.
*/
#define MAP_NAME_ATTR	"name" /**< The name of the default setting.

Use this name to refer to the value of this default in the map calculations.

Make sure that the type of this default matches the type of the parameter being set by the 
parent calculation!
*/
#define MAP_TYPE_ATTR	"type" /**< QSF will NOT convert between QOF types.

QSF will allow a conditional to use a parameter of one type to determine the value from a parameter of
another type, but the final value assigned \b MUST be of the same type as the parent calculation.
*/
#define MAP_VALUE_ATTR	"value" /**< The value of the tag, used in defaults and calculations.

The value of a default is a string representation of the value to be inserted into
the calculation where the default is used.

The value of a calculation is the name of the parameter that will be set by that calculation.
*/
#define MAP_E_TYPE	"e_type" /**< Validates the objects defined in the map 

The e_type will be used to match incoming QSF objects with the relevant QSF map.
The value of the e_type must be the value of the e_type for that object in the
originating QOF application. The define tag must contain the value of the description
of the same object in the same originating QOF application.
*/
#define MAP_ENUM_TYPE "enum"
#define QSF_XSD_TIME	"%Y-%m-%dT%H:%M:%SZ" /**< xsd:dateTime format in coordinated universal time, UTC.

You can reproduce the string from the GNU/Linux command line using the date utility: 

date -u +%Y-%m-%dT%H:%M:%SZ

2004-12-12T23:39:11Z

The datestring must be timezone independent and include all specified fields.

Remember to use gmtime() NOT localtime()!. From the command line, use the -u switch with the 
date command: date -u

To generate a timestamp based on a real time, use the qsf_time_now and qsf_time_string defaults.

qsf_time_now : Format: QOF_TYPE_DATE. The current time taken from the moment the default
is read into a QSF object at runtime.

qsf_time_string : Format: QOF_TYPE_STRING. The current timestamp taken from the moment the
default is read into a QSF object at runtime. This form is used when the output parameter 
needs a formatted date string, not an actual date object. The format is determined by the 
optional format attribute of the set tag which takes the same operators as the GNU C Library 
for strftime() and output may therefore be dependent on the locale of the calling process - 
\b take \b care. Default value is %F, used when qsf_time_string is set without the format
attribute.

Both defaults use UTC.

*/
#define QSF_XML_BOOLEAN_TEST "true" /**< needs to be lowercase for XML validation */

/** \brief A specific boolean default for this map.
*/
#define QSF_BOOLEAN_DEFAULT "boolean"

#define QSF_CONDITIONAL "if"  /**< child of calculate.

Conditionals can reference objects as if within the original application. In operation,
the map is overlaid across both sets of defined objects, an import object in the source 
application and an output object for the destination object. The current import and output 
QSF objects are therefore always available to the map. 
Conditionals can reference parameter as well as object values.
*/
#define QSF_CONDITIONAL_SET "set" /**< Assignment statement

Map assignments can use the native values within the output object. The output object
must support setting the relevant parameter using the value exactly as given in the map 
because the relevant set() function will be called using this value. This may reduce the 
readability of the map but the relevant application could also be modified to support a more 
readable set function.
*/
#define QSF_CONDITIONAL_ELSE "else" /**< Alternative

if(){} else{} is also supported. Nesting of conditionals causes problems for validating the
final map against any sensible XML Schema and a map that doesn't validate will be rejected. 
When editing conditionals in a QSF map, ALWAYS validate the map using xmllint. If necessary, 
define a variable at the foot of the definitions block, using a similar syntax to a default, 
then use that variable in another conditional

\a variable \a name="my_rate" \a type="numeric" \a value="0/1"

The syntax for xmllint is:

\a xmllint \a --schema \a &lt;schema file&gt; \a &lt;qsf-file&gt;

Use the qsf-object.xsd.xml schema for objects and qsf-map.xsd.xml for map files.

e.g. xmllint --schema qsf-object.xsd.xml --noout qof-qsf.xml

*/
#define QSF_OPTION "option" /**< enum operator

Not implemented yet - may need to change once work starts.
Theoretically, option will specify when an enumerator value is in use -
it is quite possible that it will be unnecessary.
*/

#define QSF_FORMATTING_OPTION "format" /**< How to format dates/times

When the QSF map uses a date/time value as a \b string, the formatting
can be adjusted to personal preference. \a format will only be evaluated
if the calculated parameter is a QOF_TYPE_STRING - any format attributes
on other data types will be ignored.
 */

#define QSF_OBJECT_SCHEMA "qsf-object.xsd.xml" /**< Name of the QSF Object Schema. */
#define QSF_MAP_SCHEMA "qsf-map.xsd.xml" /**< Name of the QSF Map Schema. */
/** \brief QSF Parameters

This struct is a catch-all for all parameters required
for various stages of the process. There are lots of elements
here that will finally be removed.
*/
typedef struct qsf_metadata
{
	qsf_type file_type; /**< what type of file is being handled */
	qsf_objects *object_set; /**< current object set for qsf_object_list. */
	int count; /**< sequential counter for each object in the book */
	GList *qsf_object_list; /**< list of qsf_objects */
	GSList *qsf_sequence; /**< Parameter list sorted into QSF order */
	GHashTable *qsf_parameter_hash; /**< Hashtable of parameters for each object */
	GHashTable *qsf_calculate_hash, *qsf_default_hash, *qsf_define_hash;
	GSList *supported_types; /**< The partial list of QOF types currently supported, in QSF order. */
	xmlDocPtr input_doc, output_doc; /**< Pointers to the input and output xml document(s). */
	/** \todo Review the list of xml nodes in qsf_param and rationalise. */
	xmlNodePtr child_node, cur_node, param_node, output_node, output_root, book_node, lister;
	xmlNsPtr qsf_ns, map_ns;/**< Separate namespaces for QSF objects and QSF maps. */
	const char *qof_type; /**< Holds details of the QOF_TYPE */
	QofIdType qof_obj_type;	/**< current QofObject type (e_type) for the parameters. */
	QofEntity *qsf_ent; /**< Current entity in the book. */
	QofBackend *be; /**< the current QofBackend for this operation. */
	QofBook *book;	/**< the current QofBook.

		Theoretically, QSF can handle multiple QofBooks - currently limited to 1.
	*/
	int boolean_calculation_done; /**< simple trip once this boolean is complete. */
	char *filepath; /**< Path to the QSF file. */
}qsf_param;

void qsf_free_params(qsf_param *params);


/** \brief Validation metadata

The validation is a separate parse with separate data.
This may change but it currently saves workload.

\todo Examine ways of making the Validation metadata
into a sub-set of the main code, not an island on it's own.
*/
typedef struct qsf_validates
{
	QofBackendError error_state;
	const char *object_path;
	const char *map_path;
	GHashTable *validation_table;
	int valid_object_count;
	int map_calculated_count;
	int qof_registered_count;
}qsf_validator;


/** \brief shorthand function

This may look repetitive but each one is used separately
	as well as in a block.
*/
int
qsf_compare_tag_strings(const xmlChar *node_name, char *tag_name);

/** \brief shorthand function

This may look repetitive but each one is used separately
	as well as in a block.
*/
int
qsf_strings_equal(const xmlChar *node_name, char *tag_name);

/** \brief shorthand function

This may look repetitive but each one is used separately
	as well as in a block.
*/
int
qsf_is_element(xmlNodePtr a, xmlNsPtr ns, char *c);

/** \brief shorthand function

This may look repetitive but each one is used separately
	as well as in a block.
*/
int
qsf_check_tag(qsf_param *params, char *qof_type);

/** \brief Checks all incoming objects for QOF registration.

Sums all existing objects in the QSF and counts the number of those
objects that are also registered with QOF in the host application.
*/
void
qsf_object_validation_handler(xmlNodePtr child, xmlNsPtr ns, qsf_validator *valid);

void
qsf_map_validation_handler(xmlNodePtr child, xmlNsPtr ns, qsf_validator *valid);

void
qsf_map_top_node_handler(xmlNodePtr child, xmlNsPtr ns, qsf_param *params);

void
qsf_map_object_handler(xmlNodePtr child, xmlNsPtr ns, qsf_param *params);

xmlNodePtr
qsf_add_object_tag(qsf_param *params, int count);

/** \brief Compares an xmlDoc in memory against the schema file.

@params	schema_dir  set at compile time to $prefix/share/qsf/
@params schema_filename Either the QSF Object Schema or the QSF Map Schema.
@params doc 	The xmlDoc read from the file using libxml2.

Ensure that you call the right schema_filename for the doc in question!

Incorrect validation will result in output to the terminal window.

@return TRUE if the doc validates against the assigned schema, otherwise FALSE.
*/
gboolean
qsf_is_valid(const char *schema_dir, const char* schema_filename, xmlDocPtr doc);

/** \brief Validate a QSF file and identify a suitable QSF map

@param	params	Pointer to qsf_param context

These functions are in pairs. When called from within a QofSession, the qsf_param
context will be available. When just determining the type of file, qsf_param is
not necessary. Use the *_be functions from within the QofBackend and the 
corresponding function in other code.

The file is validated against the QSF object schema, qsf-object.xsd.xml and
each object described in the file is checked to find out if a suitable QSF
map exists. Map files are accepted if all objects described in the QSF object
file are defined in the QSF map.

@return TRUE if the file validates and a QSF map can be found,
otherwise FALSE.
*/
gboolean is_qsf_object_be(qsf_param *params);

/** \brief Validate a QSF file and determine type.

@param	params	Pointer to qsf_param context

The file is validated against the QSF object schema, qsf-object.xsd.xml and
each object described in the file is checked to see if it is registered
with QOF within the QOF environment of the calling process.

Files that pass the test can be imported into the QOF appliction without the need
for a QSF map.

@return TRUE if the file validates and all objects pass,
otherwise FALSE.
*/
gboolean is_our_qsf_object_be(qsf_param *params);

/** \brief Validate a QSF map file.

@param	params	Pointer to qsf_param context

The file is validated aginst the QSF map schema, qsf-map.xsd.xsml. This
function is called by ::is_qsf_object. If called directly, the map file
is validated and closed with a QofBackend error. QSF maps do not contain
user data and are used to import QSF object files.

@return TRUE if the map validates, otherwise FALSE.
*/
gboolean is_qsf_map_be(qsf_param *params);

/** \brief Validate a QSF file and a selected QSF map

@param	map_path	Absolute or relative path to the selected QSF map file
@param	params	Pointer to qsf_param context

The file is validated against the QSF object schema, qsf-object.xsd.xml and
each object described in the file is checked to find out if the supplied QSF
map is suitable. Map files are accepted if all objects described in the QSF object
file are defined in the QSF map.

@return TRUE if the file validates and the supplied QSF map is usable,
otherwise FALSE.
*/
gboolean is_qsf_object_with_map_be(char *map_path, qsf_param *params);

/** \brief Main processing routine

Currently, only a test routine but this will process the QSF map, when required,
process the QSF object(s) and output a suitable QofBook ready for ::BookMerge

@return TRUE on success, FALSE otherwise.

*/
gboolean qsf_test_main(void);


/**	\brief QOF processing routine.

To replace the qsf_test_main routine with genuine calls to QofSession and 
qof_book_merge. Accepts QSF_OBJECT.

Checks available QSF maps for match. Only succeeds if a suitable map exists.

*/
gboolean
load_qsf_object(QofBook *book, const char *fullpath, qsf_param *params);

/**	\brief QOF processing routine.

To replace the qsf_test_main routine with genuine calls to QofSession and 
qof_book_merge. Accepts QSF_GNC_OBJECT.

*/
gboolean
load_our_qsf_object(QofBook *book, const char *fullpath, qsf_param *params);

/** \brief Export a QofBook as QSF

@param	book	QofBook*

@return NULL on error, otherwise a pointer to the xml document in memory, xmlDocPtr,
	use xmlDocDump() to write the XML to a file.
*/
xmlDocPtr
qofbook_to_qsf(QofBook *book);

void qsf_book_node_handler(xmlNodePtr child, xmlNsPtr qsf_ns, qsf_param *params);

void qsf_object_commitCB(gpointer key, gpointer value, gpointer data);

void qsf_param_init(qsf_param *params);


/** \brief map callback

Investigate ways to get the map callback to do both
the map and the validation tasks.
**/
typedef void (* qsf_nodeCB)(xmlNodePtr, xmlNsPtr, qsf_param*);

/** \brief validator callback

\todo The need for separate metadata means a separate callback typedef
	is needed for the validator, but this should be fixed to only need one.
*/
typedef void (* qsf_validCB)(xmlNodePtr, xmlNsPtr, qsf_validator*);


/** \brief One iterator, two typedefs

\todo resolve the two callbacks in ::qsf_node_iterate into one.
*/
struct qsf_node_iterate {
	qsf_nodeCB *fcn;
	qsf_validCB *v_fcn;
	xmlNsPtr ns;
};

/** \brief Validate a QSF file and identify a suitable QSF map

@param	path	Absolute or relative path to the file to be validated.

These functions are in pairs. When called from within a QofSession, the qsf_param
context will be available. When just determining the type of file, qsf_param is
not necessary. Use the *_be functions from within the QofBackend and the 
corresponding function in other code.
	
The file is validated against the QSF object schema, qsf-object.xsd.xml and
each object described in the file is checked to find out if a suitable QSF
map exists. Map files are accepted if all objects described in the QSF object
file are defined in the QSF map.

@return TRUE if the file validates and a QSF map can be found,
otherwise FALSE.
*/
gboolean is_qsf_object(const char *path);

/** \brief Validate a QSF file and determine type.

@param	path	Absolute or relative path to the file to be validated

These functions are in pairs. When called from within a QofSession, the qsf_param
context will be available. When just determining the type of file, qsf_param is
not necessary. Use the *_be functions from within the QofBackend and the 
corresponding function in other code.

The file is validated against the QSF object schema, qsf-object.xsd.xml and
each object described in the file is checked to see if it is registered
with QOF within the QOF environment of the calling process.

Files that pass the test can be imported into the QOF appliction without the need
for a QSF map.

@return TRUE if the file validates and all objects pass,
otherwise FALSE.
*/
gboolean is_our_qsf_object(const char *path);

/** \brief Validate a QSF map file.

@param	path	Absolute or relative path to the file to be validated

These functions are in pairs. When called from within a QofSession, the qsf_param
context will be available. When just determining the type of file, qsf_param is
not necessary. Use the *_be functions from within the QofBackend and the 
corresponding function in other code.

The file is validated aginst the QSF map schema, qsf-map.xsd.xsml. This
function is called by ::is_qsf_object. If called directly, the map file
is validated and closed with a QofBackend error. QSF maps do not contain
user data and are used to import QSF object files.

@return TRUE if the map validates, otherwise FALSE.
*/
gboolean is_qsf_map(const char *path);

/** \brief Write a QofBook to QSF

This function can be used to write any QofBook to QSF. Remember that
only fully \b QOF-compliant objects are supported by QSF.

Your QOF objects must have:
	- a create: function in the QofObject definition
	- a foreach: function in the QofObject definition
	- QofParam params[] registered with QOF using
		qof_class_register and containing all necessary parameters
		to reconstruct this object without any further information.
	- Logical distinction between those parameters that should be
		set (have a QofAccessFunc and QofSetterFunc) and those that 
		should only be calculated (only a QofAccessFunc).

The file is validated against the QSF object schema before being written.
Check the QofBackendError - don't assume the file is OK.

*/
void
write_qsf_from_book(FILE *out, QofBook *book);

/** \brief Determine the type of QSF and load it into the QofBook

@param	qsf_doc Pointer to the QSF object in memory, xmlDocPtr.

@return NULL on error, otherwise a pointer to the QofBook. Use
	the qof_book_merge API to merge the new data into the current
	QofBook. 
*/
void
qsf_file_type (QofBackend *be, QofBook *book);

void qsf_provider_init(void);

void
qsf_valid_foreach(xmlNodePtr parent, qsf_validCB cb,
	struct qsf_node_iterate *iter, qsf_validator *valid);

void
qsf_node_foreach(xmlNodePtr parent, qsf_nodeCB cb,
	struct qsf_node_iterate *iter, qsf_param *params);

/** \brief Loads the QSF into a QofSession, ready to merge.

Loads a QSF object file containing only GnuCash objects
into a second QofSession.

@param first_session A QofSession pointer to the original session. This
	will become the target of the subsequent qof_book_merge.
@param path	Absolute or relative path to the file to be loaded

@return ERR_BACKEND_NO_ERR == 0 on success, otherwise the QofBackendError
	set by the QSFBackend.
	
\todo Build the qof_book_merge code onto this function if session loads
	properly.
*/
QofBackendError qof_session_load_our_qsf_object(QofSession *first_session, const char *path);

/** \brief Placeholder so far.


\todo Determine the map to use and convert the QOF objects

Much of the map code is written but there is still work to do.
*/
QofBackendError qof_session_load_qsf_object(QofSession *first_session, const char *path);
	
void qsf_destroy_backend (QofBackend *be);

/** \brief Backend routine to open a file to write

Calls write_qsf_from_book to convert the QofBook to QSF XML.
*/
void qsf_write_file(QofBackend *be, QofBook *book);

/** \brief Create a new QSF backend.
*/
QofBackend* qsf_backend_new(void);
	
/** @} */
/** @} */

#endif /* QSF_XML_H */
